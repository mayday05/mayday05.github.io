---
layout:     post
title:      ARTS-2019十二月第三周
subtitle:   十二月第二周ARTS
date:       2019-12-22
author:     Mayday
header-img: img/post-bg-universe.jpg
catalog: true
tags:
    - ARTS计划
---

# 一、Algorithm

本周算法完成如下：

### 1.1 题目来源【Leetcode 108 [将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)】

### 1.2 题目描述

将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。

示例:

     给定有序数组: [-10,-3,0,5,9],
    
    一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：
    
          0
         / \
       -3   9
       /   /
     -10  5
    
    来源：力扣（LeetCode）
    链接：https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree
    著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
### 1.3 解题如下：

```java
package cn.mayday.algorithms.day20191222;

/**
 * @author: mayday
 * @version: 1.0
 *
 * 运行通过
 */
public class Leetcode108sortedArrayToBST {

    public TreeNode sortedArrayToBST(int[] nums) {
        // 异常条件直接返回
        if (nums == null || nums.length == 0) {
            return null;
        }
        return buildTreeLoop(nums, 0, nums.length - 1);
    }

    /**
     * 递归方法构造二叉树
     *
     * @param nums          原数组
     * @param leftPosition  左子树坐标
     * @param rightPosition 右子树坐标
     * @return 二叉平衡树根节点
     */
    private TreeNode buildTreeLoop(int[] nums, int leftPosition, int rightPosition) {
        // 递归结束条件
        if (leftPosition > rightPosition) {
            return null;
        }
        int middlePosition = leftPosition + (rightPosition - leftPosition) / 2;
        int value = nums[middlePosition];
        TreeNode root = new TreeNode(value);
        root.left = buildTreeLoop(nums, leftPosition, middlePosition - 1);
        root.right = buildTreeLoop(nums, middlePosition + 1, rightPosition);
        return root;
    }

    /**
     * Definition for a binary tree node.
     */
    public class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;

        TreeNode(int x) {
            val = x;
        }
    }
}

```

### 1.4 总结

这道题考核对二叉搜索树、树的构造、中序遍历的理解，归根到底为**二叉树中序遍历的逆过程**

平衡二叉搜索树特征

```
1. 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值
2. 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值
3. 任意节点的左、右子树也分别为二叉搜索树
4. 没有键值相等的节点
```

基于以上性质，我们可以得出一个二叉搜索树的特性：**二叉搜索树的中序遍历结果为递增序列**。



# 二、Review

### 2.1 文章内容

Facebook的论文《[Scaling Memcache at Facebook](https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf)》

继续上周的基本看完了，介绍了FaceBook在缓存设计的架构，集群中的延迟优化和负载处理，失败处理机制、以及多Region时的处理机制。

# 三、Tip

继续学习使用了阿里巴巴 开源的Arthas 工具，强烈推荐。





###  附 官方学习文档

 https://alibaba.github.io/arthas/

# 四、Share

本周分享文章为浩子叔的缓存更新的文章

### 4.1 文章内容

文章内容见下面链接

[缓存更新的套路](https://coolshell.cn/articles/17416.html)---左耳朵耗子

### 4.2 总结思考

#### （1）更新缓存的四种Design Pattern

- Cache aside----旁路缓存
- Read through----读缓存穿透
- Write through---写缓存穿透
- Write behind caching---先更新缓存在更新持久层【**Linux文件系统的Page Cache的算法**】

> 这些Design Pattern，其实并不是软件架构里的mysql数据库和memcache/redis的更新策略，这些东西都是计算机体系结构里的设计，比如CPU的缓存，硬盘文件系统中的缓存，硬盘上的缓存，数据库中的缓存。**基本上来说，这些缓存更新的设计模式都是非常老古董的，而且历经长时间考验的策略**，所以这也就是，工程学上所谓的Best Practice，遵从就好了

#### （2）FaceBook的做法

- 先更新数据库，再删除缓存

- 设置缓存实现时间

> 是不是Cache Aside这个就不会有并发问题了？不是的，比如，一个是读操作，但是没有命中缓存，然后就到数据库中取数据，此时来了一个写操作，写完数据库后，让缓存失效，然后，之前的那个读操作再把老的数据放进去，所以，会造成脏数据。
>
> 但，这个case理论上会出现，不过，实际上出现的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。而实际上数据库的写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，所有的这些条件都具备的概率基本并不大。

### 4.3 扩展内容

**通过2PC或是Paxos协议保证一致性如何实现** 下次补充